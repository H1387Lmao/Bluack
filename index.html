<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bluack Blockly Editor</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <script src="https://unpkg.com/blockly/lua_compressed.js"></script>
  <!-- Added Blockly English message file for Blockly.Msg definitions -->
  <script src="https://unpkg.com/blockly/msg/en.js"></script>
  <style>
    /* Ensure consistent box model */
    html, body {
      box-sizing: border-box;
    }
    *, *::before, *::after {
      box-sizing: inherit;
    }

    body {
      margin: 0;
      height: 100vh; /* Full viewport height */
      display: flex;
      flex-direction: column; /* Stack children vertically */
      font-family: monospace; /* Apply monospace to the whole body */
      background-color: #0d0d0d; /* Dark background for the whole page */
      color: #0f0; /* Green text for the whole page */
    }

    /* Main container for Blockly and controls */
    .main-container {
      flex-grow: 1; /* Allow this container to take all available vertical space */
      display: flex;
      flex-direction: column; /* Stack children (Blockly and controls) vertically within this container */
      width: 100%;
    }

    #blocklyDiv {
      flex-grow: 1; /* Allow Blockly div to take all available vertical space */
      min-height: 400px; /* Ensure a minimum height for the Blockly editor */
      width: 100%;
      background-color: #1a1a1a; /* Slightly lighter dark for Blockly area */
      border-bottom: 1px solid #333; /* Separator */
      color: #1f1f1f;
    }

    #controls {
      display: flex;
      flex-direction: column;
      background: #111;
      padding: 10px;
      border-top: 1px solid #333; /* Visual separation */
      flex-shrink: 0; /* Prevent controls from shrinking below content */
      overflow-y: auto; /* Add scrollbar if content overflows vertically */
    }

    #output {
      min-height: 90%; /* Minimum height for output */
      word-wrap: normal;
      overflow-x: auto; /* Keep horizontal scroll for long lines */
      overflow-y: auto; /* Ensure output itself scrolls vertically */
      background: #222;
      font-family: monospace;
      padding: 10px;
      border-radius: 5px; /* Slightly rounded corners */
      margin-bottom: 10px; /* Space below output */
      color: #FFF; /* Changed color to white for better visibility on dark background */
    }

    #buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 10px; /* Space between buttons */
      justify-content: center; /* Center buttons horizontally */
      margin-bottom: 10px; /* Space below buttons */
    }

    button {
      background-color: #008000; /* Green button */
      color: white;
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-family: monospace;
      font-size: 1em;
      transition: background-color 0.2s ease;
    }

    button:hover {
      background-color: #006400; /* Darker green on hover */
    }

    #console {
      max-height: 10%; /* Minimum height for console */
      overflow: auto;
      white-space: pre-wrap;
      color: #ff3333; /* Red for errors */
      background: #222;
      padding: 10px;
      border-radius: 5px;
    }

    /* Responsive adjustments */
    @media (min-width: 768px) {
      .main-container {
        flex-direction: row; /* Side-by-side on larger screens */
      }
      #blocklyDiv {
        flex: 3; /* Blockly takes more space */
        min-height: 100%; /* Fill height */
        border-bottom: none; /* No bottom border when side-by-side */
        border-right: 1px solid #333; /* Add right border */
      }
      #controls {
        flex: 1; /* Controls take less space */
        border-top: none; /* No top border when side-by-side */
        border-left: 1px solid #333; /* Add left border */
      }
      #output, #console {
        margin: 0 0 10px 0; /* Adjust margins for vertical stacking within controls */
      }
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div id="blocklyDiv"></div>
    <div id="controls">
      <div id="buttons">
        <button onclick="generateLua()">Generate Lua</button>
      </div>
      <pre id="output">-- Lua code will appear here --</pre>
      <pre id="console"></pre>
    </div>
  </div>

  <xml id="toolbox" style="display: none">
    <category name="Variables" colour="#A65C81" custom="VARIABLE"></category>
    <category name="List" colour="#DFDF32">
      <block type="lists_create_with">
        <mutation items="0"></mutation>
      </block>
      <block type="lists_setIndex"></block>
      <block type="lists_getIndex"></block>
    </category>
    <category name="Text" colour="#5CA65C">
      <block type="text"></block>
      <block type="text_print"></block>
    </category>
    <category name="Conversion" colour="#D39CFA">
      <block type="to_number"></block>
      <block type="to_string"></block>
    </category>
    <category name="Math" colour="#5C68A6">
      <block type="math_number"></block>
      <block type="math_arithmetic"></block>
    </category>
    <category name="Strings" colour="#5CA65C">
      <block type="text_concat"></block>
    </category>
    <category name="Procedures" colour="#AACCDD">
      <block type="return"></block>
    </category>
    <category name="Custom Functions" colour="#CC6680">
      <block type="function_definition_block"></block>
      <block type="function_call"></block> <!-- New function call block -->
      <block type="function_argument_get"></block> <!-- Re-added function_argument_get -->
    </category>
  </xml>

  <script>
    let workspace = null;

    // Global registry for custom function definitions (still used by function_definition_block)
    Blockly.Functions = {
      definitions: {}, // Stores {functionName: {isExpression: boolean, argumentNames: []}}

      /**
       * Registers or updates a function definition.
       * @param {Blockly.Block} block The function definition block.
       */
      registerFunction: function(block) {
        const name = block.getFieldValue('FUNCTION_NAME');
        if (name) {
          this.definitions[name] = {
            isExpression: block.isExpression_,
            argumentNames: block.argumentNames_ || []
          };
          // Toolbox refresh is now explicitly managed by the function_definition_block's onNameChange_
          // to avoid excessive updates.
        }
      },

      /**
       * Unregisters a function definition.
       * @param {Blockly.Block} block The function definition block.
       */
      unregisterFunction: function(block) {
        const name = block.getFieldValue('FUNCTION_NAME');
        if (name && this.definitions[name]) {
          delete this.definitions[name];
          // Toolbox refresh is now explicitly managed by the function_definition_block's onNameChange_
        }
      },

      /**
       * Returns a list of all defined function names for dropdowns.
       * (Still used by function_argument_get, but function_call no longer uses this for dropdown)
       * @return {!Array<!Array<string>>} Array of options for the dropdown.
       */
      getFunctionNames: function() {
        const options = [['(select function)', '']];
        for (const name in this.definitions) {
          options.push([name, name]);
        }
        return options;
      },

      /**
       * Returns the argument names for a given function.
       * @param {string} functionName The name of the function.
       * @return {!Array<string>} Array of argument names.
       */
      getFunctionArgs: function(functionName) {
        return this.definitions[functionName] ? this.definitions[functionName].argumentNames : [];
      },

      /**
       * Returns whether a given function is an expression.
       * @param {string} functionName The name of the function.
       * @return {boolean} True if the function is an expression, false otherwise.
       */
      isFunctionExpression: function(functionName) {
        return this.definitions[functionName] ? this.definitions[functionName].isExpression : false;
      }
    };


    Blockly.defineBlocksWithJsonArray([
      {
        "type": "start_block",
        "message0": "START",
        "message1": "%1",
        "args1": [
          {
            "type": "input_statement",
            "name": "BODY"
          }
        ],
        "colour": 0,
        "tooltip": "Program entry point",
        "helpUrl": ""
      },
      {
        "type": "to_number",
        "message0": "%1 %2 a number",
        "args0": [
          {
            "type": "field_label",
            "text": "make "
          },
          {
            "type": "input_value",
            "name": "number"
          }
        ],
        "output": null,
        "colour": 0,
        "tooltip": "Turns string into a number (IF NUMERICAL)",
        "helpUrl": ""
      },
      {
        "type": "to_string",
        "message0": "%1 %2 a string",
        "args0": [
          {
            "type": "field_label",
            "text": "make "
          },
          {
            "type": "input_value",
            "name": "number"
          }
        ],
        "output": null,
        "colour": 0,
        "tooltip": "Turns anything into a string",
        "helpUrl": ""
      },
      {
        "type": "text_concat",
        "message0": "%1 with %2",
        "args0": [
          {
            "type": "input_value",
            "name": "A"
          },
          {
            "type": "input_value",
            "name": "B"
          }
        ],
        "inputsInline": true,
        "output": "String",
        "colour": 160,
        "tooltip": "Concatenates two text values",
        "helpUrl": ""
      },
      {
        "type": "return",
        "message0": "return %1",
        "args0":[
          {
            "type": "input_value",
            "name": "A"
          }
        ],
        "previousStatement": null,
        "colour": 0,
        "tooltip": "Returns a value from a function",
        "helpUrl": ""
      }
    ]);

    Blockly.Lua.forBlock['start_block'] = function(block) {
      const next = Blockly.Lua.statementToCode(block, 'BODY') || "";
      return next;
    };

    Blockly.Blocks['lists_create_with'].init = function () {
      this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_HELPURL);
      this.setStyle('list_blocks');
      this.itemCount_ = 0;
      this.updateShape_();
      this.setOutput(true, 'Array');
      this.setMutator(new Blockly.icons.MutatorIcon(['lists_create_with_list'], this));
      this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_TOOLTIP);
    };

    // Override lists_create_with Lua generator to ensure correct order for table constructors
    Blockly.Lua.forBlock['lists_create_with'] = function(block) {
      const elements = new Array(block.itemCount_);
      for (let i = 0; i < block.itemCount_; i++) {
        elements[i] = Blockly.Lua.valueToCode(block, 'ADD' + i,
            Blockly.Lua.ORDER_NONE) || 'nil';
      }
      const code = '{' + elements.join(', ') + '}';
      return [code, Blockly.Lua.ORDER_ATOMIC]; // Explicitly return ORDER_ATOMIC
    };


    // Store original init functions
    const originalListsGetIndexInit = Blockly.Blocks['lists_getIndex'].init;
    const originalListsSetIndexInit = Blockly.Blocks['lists_setIndex'].init;

    // Override lists_getIndex to allow any type for the index
    Blockly.Blocks['lists_getIndex'].init = function() {
      // Call the original init function first to set up all default properties
      originalListsGetIndexInit.call(this);
      // Then, override the check for the 'AT' input (index) to allow any type
      if (this.getInput('AT')) {
        this.getInput('AT').setCheck(null); // Allows any type (number, string, etc.)
      }
    };

    // Override lists_setIndex to allow any type for the index
    Blockly.Blocks['lists_setIndex'].init = function() {
      // Call the original init function first to set up all default properties
      originalListsSetIndexInit.call(this);
      // Then, override the check for the 'AT' input (index) to allow any type
      if (this.getInput('AT')) {
        this.getInput('AT').setCheck(null); // Allows any type (number, string, etc.)
      }
    };


    Blockly.Lua.forBlock['to_number'] = function(block){
      const value = Blockly.Lua.valueToCode(block, 'number', Blockly.Lua.ORDER_NONE) || "0";
      return [`tonumber(${value})`, Blockly.Lua.ORDER_HIGH];
    }

    Blockly.Lua.forBlock['to_string'] = function(block){
      const value = Blockly.Lua.valueToCode(block, 'number', Blockly.Lua.ORDER_NONE) || "0";
      return [`tostring(${value})`, Blockly.Lua.ORDER_HIGH];
    }

    Blockly.Lua.forBlock['text_concat'] = function(block) {
      const a = Blockly.Lua.valueToCode(block, 'A', Blockly.Lua.ORDER_NONE) || '""';
      const b = Blockly.Lua.valueToCode(block, 'B', Blockly.Lua.ORDER_NONE) || '""';
      return [`${a} .. ${b}`, Blockly.Lua.ORDER_HIGH];
    };

    Blockly.Lua.forBlock['return'] = function(block){
      const value = Blockly.Lua.valueToCode(block, 'A', Blockly.Lua.ORDER_NONE) || "";
      return `return ${value}\n`;
    }

    Blockly.Blocks['lists_create_with_list'] = {
      init: function() {
        this.appendDummyInput()
            .appendField(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TITLE || 'item');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setStyle('list_blocks');
        this.setTooltip(Blockly.Msg.LISTS_CREATE_WITH_ITEM_TOOLTIP || 'An item in a list.');
        this.setHelpUrl(Blockly.Msg.LISTS_CREATE_WITH_ITEM_HELPURL || '');
      }
    };

    Blockly.Blocks['function_argument_item'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('argument:')
            .appendField(new Blockly.FieldTextInput('arg'), 'ARG_NAME');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setStyle('procedure_blocks');
        this.setColour('#CC6680');
        this.setTooltip('A function argument.');
        this.setHelpUrl('');
      }
    };

    // Block for defining a function (statement or expression)
    Blockly.Blocks['function_definition_block'] = {
      init: function() {
        this.appendDummyInput('NAME_INPUT')
            .appendField('function')
            // Bind onNameChange_ to 'this' (the block instance)
            .appendField(new Blockly.FieldTextInput('my_function', this.onNameChange_.bind(this)), 'FUNCTION_NAME')
            .appendField('(')
            .appendField('', 'ARGS_TEXT') // Placeholder for argument names
            .appendField(')');

        this.appendStatementInput('DO')
            .appendField('do');

        this.setColour('#CC6680');
        this.setTooltip('Define a function. Can be a statement or an expression.');
        this.setHelpUrl('');

        // Initial state
        this.isExpression_ = false;
        this.argumentCount_ = 0;
        this.argumentNames_ = [];

        // Mutator for arguments and expression toggle
        this.setMutator(new Blockly.icons.MutatorIcon(['function_argument_item'], this));

        // Update the block's shape based on initial state
        this.updateShape_();

        // Register the function when created or loaded
        Blockly.Functions.registerFunction(this);
      },

      /**
       * Callback for when the function name changes.
       * @param {string} newName The new name of the function.
       * @private
       */
      onNameChange_: function(newName) {
        // 'this' is now correctly bound to the block instance
        const oldName = this.getFieldValue('FUNCTION_NAME');
        if (oldName !== newName) {
          Blockly.Functions.unregisterFunction(this); // Unregister old name
          // The field value is already updated by FieldTextInput, no need to set it again here
          Blockly.Functions.registerFunction(this); // Register new name
        }
      },

      /**
       * Dispose of this block.
       * @override
       */
      dispose: function() {
        Blockly.Functions.unregisterFunction(this);
        Blockly.Block.prototype.dispose.call(this);
      },

      /**
       * Create XML to represent the number of arguments and if it's an expression.
       * @return {!Element} XML storage element.
       * @this {Blockly.Block}
       */
      mutationToDom: function() {
        const container = Blockly.utils.xml.createElement('mutation');
        container.setAttribute('arguments', this.argumentCount_);
        container.setAttribute('is_expression', this.isExpression_);
        // Store argument names
        for (let i = 0; i < this.argumentNames_.length; i++) {
          container.setAttribute('arg' + i, this.argumentNames_[i]);
        }
        return container;
      },

      /**
       * Parse XML to restore the number of arguments and expression state.
       * @param {!Element} xmlElement XML storage element.
       * @this {Blockly.Block}
       */
      domToMutation: function(xmlElement) {
        this.argumentCount_ = parseInt(xmlElement.getAttribute('arguments'), 10) || 0;
        this.isExpression_ = (xmlElement.getAttribute('is_expression') === 'true');
        // Load argument names
        this.argumentNames_ = [];
        for (let i = 0; i < this.argumentCount_; i++) {
          this.argumentNames_.push(xmlElement.getAttribute('arg' + i) || 'arg');
        }
        this.updateShape_();
        // Re-register the function after loading its state
        Blockly.Functions.registerFunction(this);
      },

      /**
       * Populate the mutator's dialog with this block's components.
       * @param {!Blockly.Workspace} workspace The workspace to add blocks to.
       * @return {!Blockly.Block} The container block for the mutator.
       * @this {Blockly.Block}
       */
      decompose: function(workspace) {
        const containerBlock = workspace.newBlock('procedures_mutatorcontainer');
        containerBlock.initSvg();

        // Add a checkbox to toggle expression vs. statement
        containerBlock.appendDummyInput()
            .appendField('is expression?')
            .appendField(new Blockly.FieldCheckbox(this.isExpression_ ? 'TRUE' : 'FALSE'), 'IS_EXPRESSION');

        let connection = containerBlock.getInput('STACK').connection;
        for (let i = 0; i < this.argumentCount_; i++) {
          const argBlock = workspace.newBlock('function_argument_item');
          argBlock.initSvg();
          if (this.argumentNames_ && this.argumentNames_[i]) {
            argBlock.setFieldValue(this.argumentNames_[i], 'ARG_NAME');
          }
          connection.connect(argBlock.previousConnection);
          connection = argBlock.nextConnection;
        }
        return containerBlock;
      },

      /**
       * Reconfigure this block based on the mutator's dialog.
       * @param {!Blockly.Block} containerBlock The container block.
       * @this {Blockly.Block}
       */
      compose: function(containerBlock) {
        // Update expression state
        const newIsExpression = (containerBlock.getFieldValue('IS_EXPRESSION') === 'TRUE');
        if (newIsExpression !== this.isExpression_) {
          this.isExpression_ = newIsExpression;
          this.updateShape_();
        }

        // Update arguments
        const newArgumentNames = [];
        let connection = containerBlock.getInput('STACK').connection;
        let childBlock = connection.targetBlock();
        while (childBlock) {
          if (childBlock.type === 'function_argument_item') {
            newArgumentNames.push(childBlock.getFieldValue('ARG_NAME'));
          }
          childBlock = childBlock.nextConnection && childBlock.nextConnection.targetBlock();
        }

        // Remove deleted arguments
        for (let i = this.argumentCount_ - 1; i >= newArgumentNames.length; i--) {
          this.removeInput('ARG' + i);
        }
        this.argumentCount_ = newArgumentNames.length;
        this.argumentNames_ = newArgumentNames; // Store for updateShape_

        // Add/update arguments
        this.updateShape_(); // Call updateShape_ to add new arguments and update text
        Blockly.Functions.registerFunction(this); // Re-register with updated arguments
      },

      /**
       * Update the block's shape (inputs/outputs) based on internal state.
       * @private
       * @this {Blockly.Block}
       */
      updateShape_: function() {
        // Update output connection
        if (this.isExpression_) {
          if (!this.outputConnection) { // If no output, add one
            this.setOutput(true, 'Function'); // Set output type to 'Function' or 'Any'
          }
        } else {
          if (this.outputConnection) { // If has output, remove it
            this.outputConnection.disconnect();
            this.setOutput(false);
          }
        }

        // Update argument inputs and text
        const currentArgs = [];
        for (let i = 0; i < this.argumentCount_; i++) {
          const argName = this.argumentNames_ ? this.argumentNames_[i] : 'arg' + i;
          currentArgs.push(argName);
        }
        this.getField('ARGS_TEXT').setValue(currentArgs.join(', '));
      }
    };

    // New block for getting function arguments (re-added)
    Blockly.Blocks['function_argument_get'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('get argument')
            .appendField(new Blockly.FieldDropdown(this.getArguments), 'ARG_NAME');
        this.setOutput(true, null); // This is an expression block
        this.setColour('#CC6680'); // Match custom functions category
        this.setTooltip('Gets the value of a function argument.');
        this.setHelpUrl('');
      },

      /**
       * Returns the available arguments from the parent function definition block.
       * @this {Blockly.FieldDropdown}
       * @return {!Array<!Array<string>>} Array of options for the dropdown.
       */
      getArguments: function() {
        const options = [['(select argument)', '']]; // Default option
        let currentBlock = this.sourceBlock_; // Start with the block that has the dropdown

        // Loop upwards through parent blocks
        while (currentBlock) {
          // Check if the current block is the function definition block
          if (currentBlock.type === 'function_definition_block' && currentBlock.argumentNames_) {
            for (let i = 0; i < currentBlock.argumentNames_.length; i++) {
              const argName = currentBlock.argumentNames_[i];
              options.push([argName, argName]);
            }
            break; // Found the function definition, stop searching
          }
          // Move to the next parent block
          currentBlock = currentBlock.getParent();
        }
        return options;
      }
    };


    // New block for calling a custom function (modified to accept any name and use mutator for args)
    Blockly.Blocks['function_call'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('call')
            .appendField(new Blockly.FieldTextInput('my_function_call'), 'FUNCTION_NAME') // Text input for any function name
            .appendField('(')
            .appendField('', 'ARGS_TEXT') // Placeholder for argument inputs
            .appendField(')');

        this.setInputsInline(true);
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setColour('#CC6680'); // Match custom functions category
        this.setTooltip('Calls a custom defined function.');
        this.setHelpUrl('');

        this.argumentCount_ = 0; // Number of arguments for this specific call block
        this.isExpressionCall_ = false; // Whether this call is for an expression function

        // Mutator for arguments and expression toggle
        // Removed 'function_call_mutator_toggle_expression' as it's not a defined block type
        this.setMutator(new Blockly.icons.MutatorIcon(['function_call_argument_item'], this));

        this.updateShape_(); // Initial shape update
      },

      /**
       * Create XML to represent the selected function and its arguments.
       * @return {!Element} XML storage element.
       * @this {Blockly.Block}
       */
      mutationToDom: function() {
        const container = Blockly.utils.xml.createElement('mutation');
        container.setAttribute('arguments', this.argumentCount_);
        container.setAttribute('is_expression_call', this.isExpressionCall_);
        return container;
      },

      /**
       * Parse XML to restore the selected function and its arguments.
       * @param {!Element} xmlElement XML storage element.
       * @this {Blockly.Block}
       */
      domToMutation: function(xmlElement) {
        this.argumentCount_ = parseInt(xmlElement.getAttribute('arguments'), 10) || 0;
        this.isExpressionCall_ = (xmlElement.getAttribute('is_expression_call') === 'true');
        this.updateShape_();
      },

      /**
       * Populate the mutator's dialog with this block's components.
       * @param {!Blockly.Workspace} workspace The workspace to add blocks to.
       * @return {!Blockly.Block} The container block for the mutator.
       * @this {Blockly.Block}
       */
      decompose: function(workspace) {
        const containerBlock = workspace.newBlock('function_call_mutator_container');
        containerBlock.initSvg();

        // Add a checkbox to toggle expression vs. statement call
        containerBlock.appendDummyInput()
            .appendField('is expression call?')
            .appendField(new Blockly.FieldCheckbox(this.isExpressionCall_ ? 'TRUE' : 'FALSE'), 'IS_EXPRESSION_CALL');

        let connection = containerBlock.getInput('STACK').connection;
        for (let i = 0; i < this.argumentCount_; i++) {
          const argBlock = workspace.newBlock('function_call_argument_item');
          argBlock.initSvg();
          connection.connect(argBlock.previousConnection);
          connection = argBlock.nextConnection;
        }
        return containerBlock;
      },

      /**
       * Reconfigure this block based on the mutator's dialog.
       * @param {!Blockly.Block} containerBlock The container block.
       * @this {Blockly.Block}
       */
      compose: function(containerBlock) {
        // Update expression call state
        const newIsExpressionCall = (containerBlock.getFieldValue('IS_EXPRESSION_CALL') === 'TRUE');
        if (newIsExpressionCall !== this.isExpressionCall_) {
          this.isExpressionCall_ = newIsExpressionCall;
          this.updateShape_();
        }

        // Update arguments
        const newArgumentCount = containerBlock.getInputTargetBlock('STACK') ?
            containerBlock.getInputTargetBlock('STACK').getDescendants(false).length : 0;

        // Remove deleted arguments
        for (let i = this.argumentCount_ - 1; i >= newArgumentCount; i--) {
          this.removeInput('ARG' + i);
        }
        this.argumentCount_ = newArgumentCount;

        // Add/update arguments
        this.updateShape_();
      },

      /**
       * Update the block's shape (inputs/outputs) based on internal state.
       * @private
       * @this {Blockly.Block}
       */
      updateShape_: function() {
        // Update output connection based on whether it's an expression call
        if (this.isExpressionCall_) {
          if (!this.outputConnection) {
            this.setOutput(true, null); // Can be any type
            this.setPreviousStatement(false);
            this.setNextStatement(false);
          }
        } else {
          if (this.outputConnection) {
            this.outputConnection.disconnect();
            this.setOutput(false);
            this.setPreviousStatement(true);
            this.setNextStatement(true);
          }
        }

        // Remove old argument inputs (if any were removed by mutator)
        // This loop ensures we only remove inputs that are no longer needed
        for (let i = this.inputList.length - 1; i >= 0; i--) {
          const input = this.inputList[i];
          if (input.name.startsWith('ARG') && parseInt(input.name.substring(3)) >= this.argumentCount_) {
            this.removeInput(input.name);
          }
        }

        // Add new argument inputs
        for (let i = 0; i < this.argumentCount_; i++) {
          if (!this.getInput('ARG' + i)) { // Only add if it doesn't exist
            this.appendValueInput('ARG' + i)
                .setAlign(Blockly.ALIGN_RIGHT)
                .appendField('arg' + i + ':'); // Default argument label
          }
        }

        // Update the ARGS_TEXT field (the parentheses content)
        this.getField('ARGS_TEXT').setValue(''); // Clear this as inputs handle arguments
      }
    };

    // Mutator container for function_call
    Blockly.Blocks['function_call_mutator_container'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('arguments');
        this.appendStatementInput('STACK');
        this.setColour('#CC6680');
        this.setTooltip('');
        this.setHelpUrl('');
      }
    };

    // Mutator argument item for function_call
    Blockly.Blocks['function_call_argument_item'] = {
      init: function() {
        this.appendDummyInput()
            .appendField('argument');
        this.setPreviousStatement(true);
        this.setNextStatement(true);
        this.setColour('#CC6680');
        this.setTooltip('Add an argument to the function call.');
        this.setHelpUrl('');
      }
    };


    // --- Lua Generator for Custom Block ---

    Blockly.Lua.forBlock['function_definition_block'] = function(block) {
      const functionName = block.getFieldValue('FUNCTION_NAME');
      const isExpression = block.isExpression_;
      const argumentNames = [];
      if (block.argumentNames_) {
        for (let i = 0; i < block.argumentNames_.length; i++) {
          argumentNames.push(block.argumentNames_[i]);
        }
      }
      const argsString = argumentNames.join(', ');

      const branch = Blockly.Lua.statementToCode(block, 'DO');
      let code = '';

      if (isExpression) {
        code = `function(${argsString})\n${Blockly.Lua.INDENT}${branch}end`;
        return [code, Blockly.Lua.ORDER_HIGH];
      } else {
        code = `local function ${functionName}(${argsString})\n${Blockly.Lua.INDENT}${branch}end\n`;
        return code;
      }
    };

    // Lua generator for the new function_call block
    Blockly.Lua.forBlock['function_call'] = function(block) {
      const functionName = block.getFieldValue('FUNCTION_NAME');
      const argValues = [];
      for (let i = 0; i < block.argumentCount_; i++) {
        const argCode = Blockly.Lua.valueToCode(block, 'ARG' + i, Blockly.Lua.ORDER_NONE) || 'nil';
        argValues.push(argCode);
      }
      const argsString = argValues.join(', ');

      let code = '';
      if (block.isExpressionCall_) {
        code = `${functionName}(${argsString})`;
        return [code, Blockly.Lua.ORDER_HIGH];
      } else {
        code = `${functionName}(${argsString})\n`;
        return code;
      }
    };

    // Lua generator for the re-added function_argument_get block
    Blockly.Lua.forBlock['function_argument_get'] = function(block) {
      const argumentName = block.getFieldValue('ARG_NAME');
      return [argumentName, Blockly.Lua.ORDER_ATOMIC];
    };


    // --- Workspace Initialization ---

    window.onload = function() {
      workspace = Blockly.inject('blocklyDiv', {
        toolbox: document.getElementById('toolbox'),
        scrollbars: true,
        pinch: true,
        trashcan: true
      });

      const startBlock = workspace.newBlock('start_block');
      startBlock.setDeletable(false);
      startBlock.initSvg();
      startBlock.render();
      startBlock.moveBy(50, 50);

      workspace.addChangeListener(function(event) {
        if (event.is
            && event.type !== Blockly.Events.UI
            && event.type !== Blockly.Events.CLICK
            && event.type !== Blockly.Events.TOOLBOX_ITEM_SELECT) {
          generateLua();
        }
      });

      generateLua();
    };

    function generateLua() {
      try {
        Blockly.Lua.init(workspace);
        const raw = Blockly.Lua.workspaceToCode(workspace);
        const code = raw.split('\n')
        .map(line => line.trimStart())
        .filter(line => line.trim() !== '')
        .join('\n');
        document.getElementById('output').textContent = code;
        document.getElementById('console').textContent = '';
      } catch (e) {
        document.getElementById('console').textContent = 'Error: ' + e.message;
        console.error(e);
      }
    }

    window.onerror = function(msg, url, line, col, error) {
      document.getElementById('console').textContent = 'JS Error: ' + msg + ' at line ' + line;
      console.error('JS Error:', msg, url, line, col, error);
    };
  </script>
</body>
</html>
